<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[重写Button实现图片drawableTop跟文字一起居中]]></title>
      <url>%2F2017%2F01%2F02%2F%E9%87%8D%E5%86%99Button%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87drawableTop%E8%B7%9F%E6%96%87%E5%AD%97%E4%B8%80%E8%B5%B7%E5%B1%85%E4%B8%AD%2F</url>
      <content type="text"><![CDATA[开发中遇到不想在Button外套一层布局，加深布局层次，原生drawableTop属性不能使其居中，需要重写Button的onDraw方法。直接上代码：123456789101112131415161718192021222324252627282930313233343536public class DrawableVerticalButton extends Button &#123; public DrawableVerticalButton(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; @Override protected void onDraw(Canvas canvas) &#123; canvas = getTopCanvas(canvas); super.onDraw(canvas); &#125; private Canvas getTopCanvas(Canvas canvas) &#123; Drawable[] drawables = getCompoundDrawables(); if (drawables == null) &#123; return canvas; &#125; Drawable drawable = drawables[1];// 上面的drawable if(drawable == null)&#123; drawable = drawables[3];// 下面的drawable &#125; float textSize = getPaint().getTextSize(); int drawHeight = drawable.getIntrinsicHeight(); int drawPadding = getCompoundDrawablePadding(); float contentHeight = textSize + drawHeight + drawPadding; int topPadding = (int) (getHeight() - contentHeight); setPadding(0, topPadding , 0, 0); float dy = (contentHeight - getHeight())/2; canvas.translate(0, dy); Log.i(&quot;DrawableTopButton&quot;, &quot;setPadding(0,&quot;+topPadding+&quot;,0,0&quot;); Log.i(&quot;DrawableTopButton&quot;, &quot;translate(0,&quot;+dy+&quot;)&quot;); return canvas; &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac 上 android 反编译apk完整流程]]></title>
      <url>%2F2016%2F12%2F14%2FMac%20%E4%B8%8A%20android%20%E5%8F%8D%E7%BC%96%E8%AF%91apk%2F</url>
      <content type="text"><![CDATA[直接进入正题，如果要在mac下反编绎apk跟在window下还是有点区别的，但是大体原理是一样的。首先下载三个工具：Apktooldex2jarjd-gui 分别介绍下这几个应用在mac下的安装Apktool，官方有明确的文档说明：Download Mac wrapper script (Right click, Save Link As apktool)Download apktool-2Rename downloaded jar to apktool.jarMove both files (apktool.jar &amp; apktool) to /usr/local/bin (root needed)Make sure both files are executable (chmod a+x filename)Try running apktool via cli 这样你就配置了bash权限，可以执行apktool命令，回车可以查看其命令集1apktool d file.apk 这样就能生成一个file的文件夹，就生成了资源文件，smile文件，如果修改了生成apk文件1apktool b file 上面的build和dist就是回编译apk过程中生成的东西，编译出来的apk在dist目录下，打开build/apk文件夹会发现少了original文件夹下的META-INF文件夹,也就意味着dist里的apk文件是没有签名的。 dex2jar,我们把.apk重命名成.zip,解压，取出classess.dex。我们要用dex2jar将apk转成jar文件，实质是将apk里的classes.dex转成jar。然后进到dex2jar这个文件夹下运行:1sh d2j-dex2jar.sh classes.dex 可能会出现1d2j-dex2jar.sh: line 36: ./d2j_invoke.sh: Permission denied 这时候就将dex2jar里的d2j_invoke.sh／d2j-dex2jar.sh增加可执行权限12chmod +x ./d2j_invoke.shsh d2j-dex2jar.sh classes.dex 这样就生成了classes-dex2jar.jar, 打开JD-GUI，将hongbao-dex2jar.jar拖进去就看到源码了。 通过看Java源码对比smali文件，修改后回编译就ok了！如何手动给apk增加签名? 回编译后的apk是安装不成功的，总是提示Failure [INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION] 实质是没签名。 1，生成签名:1keytool -genkey -keystore filename.keystore -keyalg RSA -validity 10000 -alias aliasname 注意：上面-keystore后面跟的是签名文件的名字，而-alias是别名，一般情况下-keystore后面跟-alias是一样的，但其实两者没有关系，这也是我故意搞成不一样的原因。2，为apk增加签名：1jarsigner -digestalg SHA1 -sigalg MD5withRSA -tsa -verbose -keystore filename.keystore -signedjar filename-signed.apk filename.apk aliasname 注意：1，最后的”aliasname”就是－alias后面带的，必须保持一致。2，如果不带-digestalg SHA1 -sigalg MD5withRSA签名后的apk安装也是不成功的，说INSTALL_PARSE_FAILED_NO_CERTIFICATES的错误，如果不带-tsa会报一个时间方面的警告。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[手机浏览器广告拦截实现及自动化测试]]></title>
      <url>%2F2016%2F12%2F14%2F%E6%89%8B%E6%9C%BA%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA%E5%8A%9F%E8%83%BD%E6%96%87%E6%A1%A3%2F</url>
      <content type="text"><![CDATA[1 广告拦截产品需求1.1 在页面加载过程中进行拦截（包括重新载入），做到不会让广告闪现后才被拦截 1.2 目前我们的拦截规则直接使用猎豹的规则list进行修改，通过JS注入和拦截请求的方式进行广告拦截，规则要求服务端可控，浏览器本地会存一份&quot;广告拦截规则&quot;。 1.3 广告拦截更新机制 规则文件名：libadblockrules(联盟广告通用);libadblockextrules(根据域名修改css样式); libadwhitedomainrules(白名单规则，运营需求有些网页不拦截广告) 规则更新时机：浏览器启动后，检测更新&quot;广告拦截规则&quot;； 规则更新逻辑：规则在浏览器本地有个时间戳，向服务post本地规则的时间戳进行比对，当服务器规则的时间戳新于本地的则下载新的规则进行更新，反之则不进行更新； 新规则应用时机（何时在本地起效）：更新完成规则后，下次启动浏览器时应用。 拦截提示：设置界面有提示模块 2 广告拦截实现2.1 广告拦截中文社区 2.2 ABP官方： https://adblockplus.org/en/source 这里可以下载ABP官方源码（开源组织一直在维护） 2.3 规则文件： http://abpchina.org/forum/forum.php?mod=viewthread&amp;tid=29667&amp;extra=page%3D1 ABP for android 项目已开源，github地址： https://github.com/adblockplus/adblockplusandroid 2.4 ABP官方实现： 通过设置代理，拦载请求，广告请求地址与拦截规则进行匹配，匹配到规则成功就不发送请求，自然就不会加载到请求到客户端，这种拦截通用于整个手机的 2.5 手机浏览器广告拦截具体实现： 广告规则：应用首次启动，拷贝包里的默认规则到应用的data/data/package目录下，非首次启动直接读取本地规则，将其保存到缓存;同时向服务器请求拦截规则,成功请求下来保存文件，时间戳分别保存，请求在JsHandler类请求参数如下：Requst params:1appname=androidbrowser;exrules_version=1473247972;channel=UMENG_CHANNEL_VALUE;whitelist_version=1473058756;abprules_version= 拦截时机：核心处理类在AdBlockApi 拦截有两种方式： 1).WebView加载的时候注入javascript修改网页css样式 在WebView的回调1onProgressChange()mAdblock.onProgressChanged(view); 和1onPageFinishedmAdblock.onPageFinished(view) ,两个回调中注入广告的js,主要是拦截一些banner广告和通用规则拦截导致的网页内部css样式错乱进行调整;其由通用js和规则文件js中拼接而成，具体可看代码实现。 2). shouldInterceptRequest拦载请求 Webview在加载的时候资源的每个请求以及js请求都会进行这个回调，客户端可以在这个回调中做拦截处理1mAdblock.shouldInterceptRequest(view, url, mCurrentState.mUrl) 原理是将请求中的8位一组分割，然后与缓存下来的通用规则列表通过正则来匹配，匹配成功则进行拦截，否则不拦截。匹配的效率跟资源url的长度也和正则匹配效率有关系，这也是广告拦截会影响网页加载速度的一个潜在风险。规则解析满足大部分官方提供的标准以便适用官方规则： https://adblockplus.org/zh_CN/filters，自己添加通用规则也按照此文档。 这两种方式同时时行保证了页面在被拦载导致页面错乱的情况下可以进行调整;服务器端控制规则可以保证运营需求，合作客户不拦，页面拦截异常时加白名单控制等情况（白名单针对域名）。 3 广告拦截维护两份默认规则文件都放在asset/js目录下，libadblockextrules根据官方的书写规则即可，libadblockextrules的写法与官方有差异。这里举个例子(以逗号分隔)：一条规则只单行显示1.weibo.cn,1,1,ad_banner 第一位：要拦截的网站的域名 第二位：要拦截元素的tag,0表示class，1表示id 第三位：要执行拦截操作的事件action，1表示删除节点;3表示删除上一个节点;4表示下一个节点;5表示自定义事件，用于修改复杂css样式，js自己定义 第四位：元素节点的id名称或者class名称，或者当action为5时自己定义的js字符串 日常维护这两个规则文件即可，然后提交给测试服务器。 4 广告拦截自动化为了提升运营批量定时检查广告的效率和准确度，很需要为广告拦截写一个自动化去发现广告，截图，方便运营查看。 集成开源android测试框架Robotium： 1androidTestCompile &apos;com.jayway.android.robotium:robotium-solo:5.5.4&apos; 在app androidTest包下声明一个类继承ActivityInstrumentationTestCase2 重写setup() tearDown等方法，通过Solo类来获取要测试的activity的view控件，模拟用户操作，操作其子控件，Robotium提供了官方api(下载即可)，书写脚本，然后在手机上运行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[QZone视频下载如何做到多快好省]]></title>
      <url>%2F2016%2F12%2F12%2FQzone%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%A4%9A%E5%BF%AB%E5%A5%BD%E7%9C%81%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[Qzone的日均视频播放量已经突破了10亿，其中Android端的播放量在总播放量中的占比超过70%，相比年初，播放量的增长了超过10倍。视频下载是整个视频播放的基础，如果下载侧出问题，则会造成整个视频播放的失败，这就对我们的视频下载提出了非常高的要求。 基于此，我们将视频下载总结为”多快好省”四个方面，以下载成功率、首次缓冲时长和缓冲概率为主要的技术指标对视频下载进行优化。具体参数的优化结果见下表1，经过长时间的打磨，我们的视频下载模块的下载成功率已经达到了99.9%，视频的首次缓冲时长1.2秒，二次缓冲概率低于1%，取得了良好的效果。下面我将从”多快好省”这四个方面，对我们主要的优化工作进行论述。 表1: 下载相关技术指标优化前后对比技术指标 | 下载成功率 | 首次缓冲时长 | 缓冲概率—|——|——|——|———|—优化前 | 97.1% | 2s | 15%优化后 | 99.9% | 1.2s | 0.9％ 多 在10亿这个量级下，除了保证下载的成功率和下载速度这些主要参数之外，对于整个下载流程的监控、处理异常情况显得格外重要。为了提升视频的下载成功率、稳定性，监控整个下载流程，提升用户体验，我们采用本地代理的方式进行视频下载。在Android手机上播放在线视频，最简单的方式就是实例化一个MediaPlayer, 将视频的URL通过setDataSource()设置给播放器，之后调用prepareAsync()和start()遍可以开始播放视频。这种方式非常简单，但其中最大的问题就是整个过程中的数据流完全由MediaPlayer控制，我们无法控制下载和播放的过程，也就导致我们没有办法提高成功率，优化用户体验。因此，Android侧的视频下载一般采用本地代理的方案实现。本地代理的方案即是指在播放视频的时候，将视频的URL转换为本地URL(127.0.0.1开头)，在播放器通过本地URL请求视频数据时，本地代理截获这次请求，在经过本地的处理逻辑后，向服务器或者本地缓存请求数据。本地代理在获得视频数据之后，将数据转发给播放器。 相比起直接由播放器请求数据，本地代理的优势是数据流由本地代理控制，我们可以在本地代理中加入缓存、预加载、防盗链等业务逻辑，这可以极大的提升视频下载的成功率，减少视频的缓冲时间，从而提升用户体验。 传统的本地代理方案确实解决了播放器直连带来的问题，但同样也会产生一些问题，视频下载和播放的业务逻辑复杂，过多的逻辑和下载本身耦合，给开发的过程带来极大的不便，并且这样也不容易接入第三方的下载器和对下载过程进行监控。因此，在经历了两个版本的迭代之后，我们将整个下载过程进行重构。这次重构使得下载各模块的职责明确，便于开发、维护以及接入第三方的下载，也为我们后续的优化打下基础，重构之后的方案会在之后单独成文介绍。 快 国外SmartBear的研究表明，57%的用户在3秒没有加载完网页时就会放弃。在视频播放上，加快视频的加载速度，减少播放过程中的卡顿，对提高用户观看视频的体验有极大的帮助。经过我们长期的优化，现在Qzone视频播放的接近秒开，缓冲概率下降到不到1%，这极大的提升了用户体验，也从侧面提升了我们的视频播放量。 在这数据提升的背后，我们主要做了几个方面的工作： 2.1：防盗链预拉取 盗链播放在国内非常普遍，而盗链会使平台资源流失，增加带宽成本，不利于平台的长期发展，国内大部分视频服务提供商都在一定程度上做了防盗链。防盗链的主要过程是后台下发的视频URL，在正式播放之前，需要通过URL中的部分参数，加上一些本地参数，向后台拉取真正播放的URL, 这些真正播放的URL都带有时效性，这种方式可以从一定程度上避免盗链行为。但通过防盗链接口拉取真实的播放URL需要时间，这也在一定程度上延长了用户感知的视频加载时间。针对这种情况，我们对防盗链的模块进行了改造，引入预拉取机制，将防盗链的拉取与播放解耦，对用户的播放行为进行预判，在用户播放视频的过程中提前拉取并缓存之后视频的URL, 从而减少了因为拉取防盗链URL造成的视频缓冲时间。 2.2：数据预加载： 从MediapPlayer的源码可以发现（AwesomePlayer.cpp）, MediaPlayer需要下载5秒的数据才会开始播放视频，按照现在的外网平局下载速度计算，该过程的耗时在接近1秒，因此对于数据进行预加载是减少视频首次缓冲非常重要的方法。但视频数据的预加载不能跟当前播放的视频抢下载带宽，因此我们选择以当前播放视频的播放进度和数据缓存量为维度，当两者同时达到一个阀值时开始下载下一个视频的数据。在实践的过程中，我们还发现，因为一些编码格式的原因，MediaPlayer在播放视频之前可能会请求一部分尾部数据，因此，视频预加载还会加载一部分尾部数据，最大限度的保证预加载的效果。 2.3：缓存改造 MediaPlayer加载本地视频的效率远高于在线下载，因此，缓存的命中率会直接影响到视频缓冲的速度。最初的缓存方案是针对单个视频按照顺序缓存，这样实现简单，但存在的问题就是无法对于播放空洞（非顺序播放场景，例如拖动、续播等）进行缓存，这降低了视频的缓存率和缓存命中率，增加了带宽成本和视频的缓冲时长。之后我们针对缓存模块进行了改造，将顺序缓存改为分片缓存，即将单个视频的缓存按照一定大小进行分片，在遇到数据空洞或者缓存数据量达我们设置的单片缓存上限时，开启下一个分片缓存，确保可以缓存所有的下载数据。这样改造之后极大的提升了缓存命中率，降低了首次缓冲时间和二次缓冲的概率。 2.4：性能优化 梳理下载和播放过程中整体的流程，通过工具排查流程中长耗时的点和优化过程中的逻辑，减少不必要的耗时和操作，并将部分耗时逻辑移入子线程；优化时序，将例如图片加载、缓存IO等重逻辑执行的时机后移，以及对视频播放关联度不高的逻辑使用懒加载。这样可以降低对于视频播放，特别是视频缓冲过程中，CPU和IO的占用，使得系统能够调度更多的资源在解封装、解码、渲染等与播放、下载直接相关的操作上，进而减少这部分的耗时。 好 下载的成功率是保证视频观看体验的基础，目前Qzone的视频下载成功率已经提升至99.9%，跟主要命令字的成功率相当。国内的移动网络环境错综复杂，不仅要处理断网、慢速、抖动等网络本身的题，还要处理跨网、运营商劫持等国情问题。下载成功率的提升过程非常艰难，我们在其中主要做了以下的工作：3.1： IP直出与竞速 通过IP直出减少了DNS劫持的可能性；对于下层代理的视频下载下发多组IP，通过竞速计算本地最佳IP，使用最佳IP进行直出下载；上层代理对于下层代理的整个下载过程进行监控，在监测到下载速度缓慢或者异常情况时（IP连接失败、数据读取超时等）立即切换下载IP，减少用户的视频加载时间。通过IP直出、竞速和切换，提高了下载的连接、数据读取成功率，减少了因DNS劫持导致下载失败的概率，同时提高了下载速度。 3.2：对于链接失效（403）进行处理 上文（2.1章节）中提到Qzone视频播放的链接均是经过防盗链处理，带有播放效期的链接，这就使得，在实际播放的场景中，很可能出现用户希望播放某视频时，跟随后台下发的视频链接已经过期失效的情况，如果不进行处理，则会极大降低下载的成功率。针对这种情况，我们根据视频的不同来源，对于每种情况进行异化处理，通过向后台重新拉取链接或者本地计算Key，解决了因连接中的Key失效导致视频无法播放的问题。 3.3：下载命令字拉取接入私有通道 Qzone很早就开始采用维纳斯（WNS, Wireless Network Service）私有通道方案进行网络数据传输，相比使用最多的Http方案，WNS通过长连接、IP直出、接入点优化、数据压缩等方法，提高了网络连接的成功率和稳定性。为了提高主要命令字的拉取成功率，我们对原有用Http拉取命令字的方式进行改造，使用WNS通道包裹原来的Http数据包，在后台通过WNS通道收到原有的请求后再将请求分发至对应的后台，具体的流程如下图4所示。这样通过低成本的改造（不需要修改原有协议，后台直接透传基本没有开发工作量），借由WNS提升了整个通道的传输质量，进而也提高了视频的下载成功率。 3.4：下载速率动态调节 在移动网络下，发生网络抖动和网络切换经常发生，但网络不稳定，对下载来说是非常致命的。为了应对网络抖动和网络切换，下层代理会监听当前的网络变化，监控当前的下载速度。下层代理在下载数据时，为了减少对于别的业务影响，不会占用全部的带宽，但当发生频繁的网络切换时，下载代理会主动突破速度的限制，尽可能快的在网络情况良好时下载数据，给之后的播放留下足够的数据Buffer，保证整体播放的流畅性。 省 互联网的视频服务提供商在国内盈利极其困难，除了近几年视频市场竞争越来越激烈，版权费居高不下之外，国内高昂的带宽成本也是重要原因。因此，如何在保证视频质量的前提下，尽可能减少下载流量，减少下载而产生的带宽成本，对于我们来说也是非常重要的工作。在这部分，我们主要的工作如下： 4.1: 流量控制 为了保证用户观看的流畅性，减少视频缓冲，视频数据下载的可播放量与当前观看的时间点之前会保持一定的Buffer，在整个播放过程中，通过动态调节下载速度，这个Buffer的大小基本保持不变，并且Buffer的大小可以动态调节。在流量高峰的时间段，我们会通过后台进行流量控制，减少Buffer，也就减少了高峰时段整体的下载量。带宽的计费标准一般按照高峰流量计费，减少了高峰时段的流量，也就降低了带宽成本。具体流控如下图，高峰时段视频缓冲M秒，非高峰时段缓冲N秒，N&gt;M，两个参数均可由后台控制。 4.2: H265编码 H265是新一代视频编码标准，相比原有使用H264编码的视频，具有更高的压缩比，在画质近似的前提下，H265编码的视频文件体积只有H264的一半甚至更少，因此，播放H265编码的视频能极大减少带宽消耗。但H265现阶段主要存在的问题是终端编码耗时过长，后台编码过于消耗资源，以及在Android手机上，软解码（Android支持H265硬解码的机型较少，并且硬解码的兼容性问题相比软解更多）带来的耗电、发热以及兼容性问题。目前，Qzone通过自解码播放器，在经过大量的兼容性测试之后，已经在超过100款主流Android手机上实现了H265视频的软解播放。空间视频H265和H264编码的下载带宽对比以及之后的预期情况如下图6所示，可以明显看出，通过H265编码极大的降低了我们的视频下载带宽成本。 另外在2.3中论述对于视频缓存的分片改造，同时提升了下载数据缓存的使用率和命中率，也了减少了我们的视频下载带宽。 总结 经过长时间的优化，Qzone视频业务，包括下载成功率、播放成功率、缓冲概率、首次缓冲时长等在内的主要技术指标，均得到了大幅度的提升，达到了我们的预期，也为Qzone视频点播和直播业务的持续发力铺平了道路。但技术优化是一个长期的过程，目前Qzone的视频播放已经开始启用自解码播放器，逐步替换原生的MediaPlayer，之后我们还会通过播放器多实例，编解码，参数调节等方式进一步提升视频下载成功率，压缩视频缓冲时间，减少缓冲概率。也欢迎各位多使用Qzone体验我们在各个场景中的视频播放，如果对体验或者技术优化的建议和意见，欢迎交流。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代码Review流程与操作步骤]]></title>
      <url>%2F2016%2F12%2F11%2FGitlab%20%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[fork 主仓库，创建自己的仓库主仓库地址：http://172.16.0.245:2345/user/android_browser_codereview 拉取子仓库地址到本地1git clone ******(自己fork 之后的仓库地址) 跟踪主仓库1git remote add upstream git@172.16.0.245:user/android_browser_codereview.git 更新主仓库代码1git fetch upstream 合并主仓库分支到本地分支1git merge upstream/master 提交本地仓库代码到主仓库1.登录gitlab ,选中个人仓库2.发起 Merge Requests3.选择 Source branch4.选择 Target branch 参考资料1 使用 git rebase 避免無謂的 merge git pull –rebase加上 rebase 的意思是，會先 1.把本地 repo. 從上次 pull 之後的變更暫存起來 2. 回復到上次 pull 時的情況 3. 套用遠端的變更 4. 最後再套用剛暫存下來的本地變更 .git/config 中配置1.user 信息配置在 config 文件中添加如下信息，用户名和邮箱地址替换为自己的账号以及邮箱123[user]name = useremail = user@2345.com 2.指定分支 使用 git pull –rebase1234[branch &quot;master&quot;]remote = originmerge = refs/heads/masterrebase = true 3.所有分支添加 git pull –rebase12[branch] autosetuprebase = always]]></content>
    </entry>

    
  
  
</search>
